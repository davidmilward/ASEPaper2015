\section{Implementation}

The Models Catalogue, like many software developments, evolved from a mix of requirements on a number of different projects.  Initially a metadata registry was built using an XML database, however problems were encountered with scalability.  Most of the language and metamodel developments were carried out using XText and the Eclipse Modelling Framework, resulting in a usable java code base, however usability requirements neccessitated the refactoring of this software using a stack consisting of Grails and Angular JS. 

Grails is built on the Spring framework, which is not only proven to be very robust and scalable, but is also relatively easy to implement and so enables quick agile development cycles. Previous implementations using Java/Spring and Java/Roo have proved very time-consuming to experiment with, whereas Grails has proven to be more flexible and easier to experiment with.  Domain specific languages (DSLâ€™s) can be  built on this framework, and this capability offered scope to build a DSL based on the LEM DSL specification and meta-model expanded in the previous section.
 
The front end user interface was implemented using a combination of HTML with Javascript and CSS, the principal framework used being Angular JS. Communication with the client was carried out using a REST controller, enabling a variety of clients potentially to link up with the Model Catalogue.

GORM was used as a persistence mechanism, with a MySQL relational database as storage, although different GORM adapters made it possible to attach NO SQL datastores such as Neo4J and MongoDB. The full architectural stack is shown in figure\ref{fig:ApplicationArchitectMDR}

\begin{figure}[here]
	\includegraphics[width=0.48\textwidth,natwidth=610,natheight=642]{ApplicationArchitect1}
	\caption{Overview Architecture} 
	\label{fig:ApplicationArchitectMDR}
\end{figure}

The Grails/GORM framework enabled the Ecore model to generate the basic Grails Domain model, and from that a Groovy DSL was built, using the Builder pattern, to handle transformations internally between different representational languages such as XML and Excel. A series of importers was built for data input from Excel, CSV, and various XML variants. Most XML structures are handled by transforming the XML from its native structure to our internal DSL-based XML structure. 

The internal domain model used a basic \emph{Catalogue Element} which was able to link elements via the \emph{relationship} and \emph{relationshipType} classes. The core language model discussed earlier has been enhanced to by allowing user-defined relationships to be added to the core model. Any catalogue element is able to be related to any other catalogue element through a relationship class, this relationship is constrained by the relationshipType object which can prevent different catalogue element types being related, so that a Model cannot directly be related to a say a Datatype Enumeration. Relationship types can be added to the Model dynamically, so that even though the relationship between a Model and Datatype enumeration is prevented initially, a new type could be introduced by an administrator or super user to add in that relationship. The EMF-based tools to automatically generate the whole Models Catalogue code-base using Groovy/Grails/Angular were not available at the start of the project, and although work has been undertaken to build such a toolkit it not yet complete.  

The following subsections describe the basic use cases for the Model Catalogue, and how these use cases were implemented. 
\subsection{Listing of DataModels}
The key use case required in both projects was the ability to catalogue a set of data elements and data classes so that different schema could be compared and curated. Listing is currently carried out using a REST interface which is queried using an Angular client. Figure \ref{fig:treeviewOfDataModel}
\begin{figure}[here]
	\includegraphics[width=0.5\textwidth,natwidth=610,natheight=642]{DataModelTreeView}
	\caption{Screen Shot of DataModel Listing} 
	\label{fig:treeviewOfDataModel}	
\end{figure}

\subsection{selection of data elements for form generation}
For many clinical users one of the key requirement was the ability to generate forms for clinical research which were generated form a single authorative source, and the ability to take data elements, manage them to build a form and then output either a form or an XML representation for use in another system, such as OpenClinica was key to the work carried out. Figure \ref{fig:treeviewOfDataModel} shows the interface for selecting and managing users selections of data elements and data classes.
\begin{figure}[here]
	\includegraphics[width=0.5\textwidth,natwidth=610,natheight=642]{DataElementSelection}
	\caption{Screen Shot of Data Element Selection} 
	\label{fig:treeviewOfDataModel}	
\end{figure}


\subsection{relationships between 2 DataModels}
Very often different research groups will arrive at slightly different models for the same or very similar diseased, so another use case for the Models Catalogue was the ability to compare different Data Models, Data Classes and individual Data Elements. Figure \ref{fig:dataClassComparison}
\begin{figure}[here]
	\includegraphics[width=0.5\textwidth,natwidth=610,natheight=642]{ComparisonOfDataClasses}
	\caption{Screen Shot of DataClass Comparison} 
	\label{fig:dataClassComparison}	
\end{figure}







%%-------------------------------
%%Drop next section
%%------------------------------
%%Some of the main relationships that are currently modelled in the \emph{Models Catalogue} are as follows:
 %%
%%\begin{center}
%%	\begin{tabular}{ p{1.5cm}  p{1.5cm}  p{1.5cm}   }  % centered columns (5 columns)
%%		Source & Relationship & Destination  \\
%%		Model & containment & DataElement   \\
%%	    Model & containment & Class    \\
%%	    Model & hierarchical & Model  \\
%%	    DataElement & supersession & DataElement  \\          
%%	\end{tabular}
%%\end{center}
%%
%%The Core architecture can seen in figure\ref{fig:ApplicationArchitectMDR} 
%%
%%\begin{figure}[here]
%%	\includegraphics[width=0.5\textwidth,natwidth=610,natheight=642]{System2}
%%	\caption{Overview Architecture} 
%%	\label{fig:System2MDR}
%%\end{figure}
%% 
\subsection{Modelling Overview}





 
 